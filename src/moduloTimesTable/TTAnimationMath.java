package moduloTimesTable;

import javafx.scene.paint.Color;
import javafx.scene.shape.Line;


/**
 * Class contains functions to complete math operations
 * required for the Modulo Times Table animation i.e.
 * calculating the locations of the coordinates along the main circle
 * as well as the lines. Function are called in Controller.
 */
class TTAnimationMath {

    /**
     * Returns an array of coordinates on the points of the circle for animation.
     *
     * @param num number of coordinates to create
     * @return  coords coordinates generated as an arrray
     */
    static Coordinates[] calcPointCoordinates(int num) {
        final float STEP = (float) (2 * Math.PI / (num)); //Step in radians
                                                            // for algorithm
        final int CENTER = 450; //center of pane object
        final int R = 350; //Radius of circle
        float theta = (float) Math.PI; //Current radian angle
                                            // to be increased by step
        int i = 0;
        Coordinates temp;
        Coordinates[] coords = new Coordinates[num];

        while(i < num) {
            temp = new Coordinates();
            temp.setX((float) (CENTER + R * Math.cos(-theta)));
            temp.setY((float) (CENTER + R * Math.sin(-theta)));
            coords[i] = temp;
            theta -= STEP;
            i++;
        }

        return coords;
    }

    /**
     *
     * @param val current value to be multiplied by times step
     * @param timeStep  time step
     * @param points    coordinates generated by calcPointCoordinates()
     * @param currentColor color desired for line, usually current color
     * @param dots      number of dots in animation
     * @return Line     Multiplication line  from initial value to relative coordinate
     *                  of specific color
     */
    static Line calcLine(int val, int timeStep, Coordinates[] points,
                         Color currentColor, int dots)
    {
        float x1, y1, x2, y2;
        int nextPointIndex,
                currentPointIndex = (val % dots);
        if(currentPointIndex < 0) currentPointIndex = 0;
        Coordinates currentPoint = points[currentPointIndex];
        Line line;

        x1 = currentPoint.getX();
        y1 = currentPoint.getY();
        nextPointIndex = ((val * timeStep) % dots);
        if (nextPointIndex < 0) nextPointIndex = 0;
        x2 = points[nextPointIndex].getX();
        y2 = points[nextPointIndex].getY();
        line = new Line(x1, y1, x2, y2);
        line.setStroke(currentColor);
        return line;
    }
}
